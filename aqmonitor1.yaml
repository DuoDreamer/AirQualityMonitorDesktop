# Sensorbox v2 config for PCB SBR1
# config r2 (20241130)
# https://go.toms3d.org/sbr1
# Leave the "substitutions" block in place, then add this config.
# You can choose a new "friendly name" in the substitutions, this will be its display name in Home Assistant.

#sensors on my build:
# AHT20 / BMP280 combo board / humidity/temp/pressure
# SCD41 Gas Sensor
# SGP30 TVOC sensor
# PMS5003 Particulate Sensor

esphome:
  name: aqmonitor1
  friendly_name: AQMonitor 1
  min_version: 2024.6.0
  name_add_mac_suffix: false
  platformio_options:
    board_build.flash_mode: dio
  project:
    name: esphome.web
    version: dev

esp32:
  board: esp32-s2-saola-1
  framework:
    type: arduino

#required to explicitly instantiate PSRAM for LCD
psram:
  mode: quad
  speed: 80MHz

# Enable logging
logger:

# Enable Home Assistant API and failsafe mechanisms
api:
  encryption:
    key: !secret api_key


# Allow Over-The-Air updates
ota:
  platform: esphome
  password: !secret ota_password_env


# Allow provisioning Wi-Fi via serial
improv_serial:

wifi:
  use_address: aqmonitor1
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails, using your wifi's password
  ap:
    ssid: "AQMonitor1"
    password: !secret ap_mode_password


# In combination with the `ap` this allows the user
# to provision wifi credentials to the device via WiFi AP.
captive_portal:

dashboard_import:
  package_import_url: github://esphome/firmware/esphome-web/esp32s2.yaml@main
  import_full_config: true

# To have a "next url" for improv serial
web_server:



debug:
  update_interval: 5s

# Display dimming
globals:
   - id: dbright
     type: int
     restore_value: no
     initial_value: '0'
     
output:
  - platform: ledc
    pin: GPIO15
    id: backlight_pwm

light:
  - platform: monochromatic
    output: backlight_pwm
    name: "Display Backlight"
    id: back_light
    restore_mode: ALWAYS_ON

binary_sensor:
  - platform: gpio
    pin:
      number: GPIO13
      mode:
        input: true
        pullup: true
      inverted: true
    id: top_btn
    filters:
      - delayed_on: 10ms
      - delayed_off: 500ms
    on_press: 
      then:
        - lambda: |-
            switch(id(dbright)){
            case 0: id(dbright) = 3; id(back_light).turn_on().set_brightness(1.00).perform(); return;
            case 1: id(dbright) = 0; id(back_light).turn_off().perform();                     return;
            case 2: id(dbright) = 1; id(back_light).turn_on().set_brightness(0.33).perform(); return;
            case 3: id(dbright) = 2; id(back_light).turn_on().set_brightness(0.66).perform(); return;
            }

# /Display dimming




font:
  - file: "gfonts://Rubik@300"
    id: font_label_14
    size: 14
    bpp: 4
    glyphs: [
      "0","1","2","3","4","5","6","7","8","9", "µ", "³",  "/", "°", "%", ",", ".", "(", ")", "-", "_", A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P,Q,R,S,T,U,V,W,X,Y,Z," ",a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z
      ]
  - file: "gfonts://Rubik@400"
    id: font_value_30
    size: 30
    bpp: 4
    glyphs: [
      "0","1","2","3","4","5","6","7","8","9", "."
      ]
  - file: "gfonts://Orbitron"
    id: font_heading_36
    size: 36
    bpp: 4
    glyphs: [
      "2",C,O,P,V,a,c,e,i,l,r,s,t
      ]


color:
  - id: white
    hex: FFFFFF
  - id: grey
    hex: AAAAAA
  - id: light_grey
    hex: CCCCCC
  - id: green
    hex: 16FF16
  - id: yellow
    hex: FFFA72
  - id: orange
    hex: FF9C32
  - id: red
    hex: FF1616
  - id: purple
    hex: FF16E0
  - id: blue
    hex: 202080

display:
  - platform: ili9xxx
    model: ILI9341
    cs_pin: GPIO03
    dc_pin: GPIO04
    reset_pin: GPIO06
    transform:
      mirror_y: true
    color_order: bgr
    color_palette: 8BIT
    invert_colors: false
    update_interval: 5s               # keep the same
    lambda: |-
      /* --------------------------------------------------------------
         CONSTANTS – heights of each visual lane (in pixels)
       ----------------------------------------------------------------*/
      const uint16_t H_TEMP_HUM   = 40;   // two tiny boxes at the top
      const uint16_t H_ROW        = 88;   // particles, CO₂ and VOC rows
      const uint16_t H_SGP41_IDX  = 40;   // SGP41 index row

      static bool first_run = true;
      if (first_run) {
        it.fill(Color::BLACK);          // clear once on boot
        first_run = false;
      }

      /* --------------------------------------------------------------
         Short‑hand aliases – makes the lambda easier to read
       ----------------------------------------------------------------*/
      auto fv30  = id(font_value_30);
      auto fh36  = id(font_heading_36);
      auto fl14  = id(font_label_14);
      const uint16_t w = it.get_width();

      /* --------------------------------------------------------------
         Grab sensor states (the `id(...).state` calls are cheap)
       ----------------------------------------------------------------*/
      const float co2   = id(co2_scd40).state;
      const float e_co2 = id(eco2_ens160).state;
      const float s_co2 = id(eco2_sgp30).state;

      const float ch2o  = id(ch2o_ze08).state;
      const float e_voc = id(tvoc_ens160).state;
      const float s_voc = id(tvoc_sgp30).state;

      const float pm1   = id(pm1_pms).state;
      const float pm25  = id(pm25_pms).state;
      const float pm10  = id(pm10_pms).state;

      const float aqi_voc = id(aqi_voc_sgp41).state;
      const float aqi_nox = id(aqi_nox_sgp41).state;

      /* --------------------------------------------------------------
         Helper: colour‑coding based on thresholds (unchanged from yours)
       ----------------------------------------------------------------*/
      auto get_color = [&](float v, const Color &green,
                           const Color &yellow, const Color &orange,
                           const Color &red, const Color &purple) -> Color {
        if (std::isnan(v)) return green;               // fallback
        if (v > 1500) return purple;
        if (v > 1200) return red;
        if (v > 1000) return orange;
        if (v > 700)  return yellow;
        return green;
      };

      const Color col_co2   = get_color(co2,   id(green), id(yellow), id(orange), id(red), id(purple));
      const Color col_e_co2 = get_color(e_co2, id(green), id(yellow), id(orange), id(red), id(purple));
      const Color col_s_co2 = get_color(s_co2, id(green), id(yellow), id(orange), id(red), id(purple));

      const Color col_ch2o  = get_color(ch2o,  id(green), id(yellow), id(orange), id(red), id(purple));
      const Color col_e_voc = get_color(e_voc, id(green), id(yellow), id(orange), id(red), id(purple));
      const Color col_s_voc = get_color(s_voc, id(green), id(yellow), id(orange), id(red), id(purple));

      const Color col_pm1   = get_color(pm1,   id(green), id(yellow), id(orange), id(red), id(purple));
      const Color col_pm25  = get_color(pm25,  id(green), id(yellow), id(orange), id(red), id(purple));
      const Color col_pm10  = get_color(pm10,  id(green), id(yellow), id(orange), id(red), id(purple));

      /* --------------------------------------------------------------
         Temperature & Humidity – **always** drawn at the very top.
         They occupy a fixed 40‑pixel high lane (0 … H_TEMP_HUM).
       ----------------------------------------------------------------*/
      // ---- temperature ------------------------------------------------
      static float prev_temp_f = NAN;
      static uint32_t last_temp_update = 0;
      if (!std::isnan(id(temp_sht40).state) ||
          !std::isnan(id(temp_aht20_c).state) ||
          !std::isnan(id(temp_scd40).state) ||
          !std::isnan(id(temp_aht20_ens).state) ||
          !std::isnan(id(temp_bmp280).state)) {

        // pick the first non‑NaN temperature (your original order)
        const float temps[5] = {
          id(temp_sht40).state, id(temp_aht20_c).state,
          id(temp_scd40).state, id(temp_aht20_ens).state,
          id(temp_bmp280).state };
        float temp_c = NAN;
        for (auto t : temps) if (!std::isnan(t)) { temp_c = t; break; }

        if (!std::isnan(temp_c)) {
          const float temp_f = temp_c * 1.8f + 32.f;
          bool changed = std::fabs(temp_f - prev_temp_f) > 0.01f;   // tiny tolerance
          bool stale   = (millis() - last_temp_update) > 45000UL;

          if (changed || stale) {
            it.filled_rectangle(60, 0, 80, H_TEMP_HUM, Color::BLACK);
            it.printf(90, 30, fl14, id(grey), TextAlign::BOTTOM_LEFT, "°F");
            it.printf(90, 34, fv30, id(white), TextAlign::BOTTOM_RIGHT,
                      "%.1f", temp_f);
            prev_temp_f = temp_f;
            last_temp_update = millis();
          }
        }
      }

      // ---- humidity ---------------------------------------------------
      static float prev_hum = NAN;
      static uint32_t last_hum_update = 0;
      if (!std::isnan(id(hum_sht40).state) ||
          !std::isnan(id(hum_aht20).state) ||
          !std::isnan(id(hum_scd40).state) ||
          !std::isnan(id(hum_aht20_ens).state)) {

        const float hums[4] = {
          id(hum_sht40).state, id(hum_aht20).state,
          id(hum_scd40).state, id(hum_aht20_ents).state };
        float hum = NAN;
        for (auto h : hums) if (!std::isnan(h)) { hum = h; break; }

        if (!std::isnan(hum)) {
          bool changed = std::fabs(hum - prev_hum) > 0.01f;
          bool stale   = (millis() - last_hum_update) > 45000UL;

          if (changed || stale) {
            it.filled_rectangle(150, 0, 90, H_TEMP_HUM, Color::BLACK);
            it.printf(197, 18, fl14, id(grey), TextAlign::BOTTOM_LEFT, "RH");
            it.print(197, 30, fl14, id(grey), TextAlign::BOTTOM_LEFT, "%");
            it.printf(197, 34, fv30, id(white), TextAlign::BOTTOM_RIGHT,
                      "%.1f", hum);
            prev_hum = hum;
            last_hum_update = millis();
          }
        }
      }

      /* --------------------------------------------------------------
         Helper: draw a three‑column row (particles, CO₂, VOC)
         The function only erases **its own lane** – never touches the
         temperature/humidity area above.
       ----------------------------------------------------------------*/
      auto draw_row = [&](int y, const char *title, const char *unit,
                          const char *names[3], const float values[3],
                          const Color colors[3]) {
        // erase only this row (height = H_ROW)
        it.filled_rectangle(0, y, w, H_ROW, Color::BLACK);
        // separator line at the top of the row
        it.line(0, y, w, y, id(white));

        // title & unit
        it.print(2, y + 22, fh36, id(blue), TextAlign::CENTER_LEFT, title);
        it.print(w - 2, y + 31, fl14, id(grey), TextAlign::CENTER_RIGHT, unit);

        // three columns – only draw the ones that are not NaN
        int col_idx = 0;
        for (int i = 0; i < 3; ++i) {
          if (std::isnan(values[i])) continue;
          float v = values[i];
          const char *n = names[i];
          Color c = colors[i];

          // X position: centre of each column (1/6, 3/6, 5/6 of width)
          int x_center = w / 6 * (1 + col_idx * 2);
          it.printf(x_center, y + 58, fl14, id(grey),
                    TextAlign::BOTTOM_CENTER, "%s", n);
          it.printf(x_center, y + 50, fv30, c,
                    TextAlign::TOP_CENTER, "%.0f", v);
          ++col_idx;
        }
      };

      /* --------------------------------------------------------------
         Now draw the remaining blocks – each one checks “changed or stale”
         and erases only its own rectangle.
       ----------------------------------------------------------------*/
      uint32_t now = millis();

      // ---- Particles -------------------------------------------------
      static float prev_pm[3] = {NAN, NAN, NAN};
      static uint32_t last_pm_update = 0;
      if (!std::isnan(pm1) || !std::isnan(pm25) || !std::isnan(pm10)) {
        const char *names[3] = {"PM1", "PM2.5", "PM10"};
        float vals[3]   = {pm1, pm25, pm10};
        Color cols[3]   = {col_pm1, col_pm25, col_pm10};

        bool changed = false;
        for (int i = 0; i < 3; ++i)
          if (!std::isnan(vals[i]) && vals[i] != prev_pm[i]) changed = true;

        bool stale = (now - last_pm_update) > 45000UL;
        if (changed || stale) {
          draw_row(H_TEMP_HUM, "Particles", "µg/m³",
                   names, vals, cols);
          for (int i = 0; i < 3; ++i) prev_pm[i] = vals[i];
          last_pm_update = now;
        }
      }

      // ---- CO₂ -------------------------------------------------------
      static float prev_co2[3] = {NAN, NAN, NAN};
      static uint32_t last_co2_update = 0;
      if (!std::isnan(co2) || !std::isnan(e_co2) || !std::isnan(s_co2)) {
        const char *names[3] = {"SCD40", "ENS160 est.", "SGP30 est."};
        float vals[3]   = {co2, e_co2, s_co2};
        Color cols[3]   = {col_co2, col_e_co2, col_s_co2};

        bool changed = false;
        for (int i = 0; i < 3; ++i)
          if (!std::isnan(vals[i]) && vals[i] != prev_co2[i]) changed = true;

        bool stale = (now - last_co2_update) > 45000UL;
        if (changed || stale) {
          draw_row(H_TEMP_HUM + H_ROW, "CO₂", "ppm",
                   names, vals, cols);
          for (int i = 0; i < 3; ++i) prev_co2[i] = vals[i];
          last_co2_update = now;
        }
      }

      // ---- VOC -------------------------------------------------------
      static float prev_voc[3] = {NAN, NAN, NAN};
      static uint32_t last_voc_update = 0;
      if (!std::isnan(ch2o) || !std::isnan(e_voc) || !std::isnan(s_voc)) {
        const char *names[3] = {"SGP30", "ENS160", "ZE08‑CH₂O"};
        float vals[3]   = {s_voc, e_voc, ch2o};
        Color cols[3]   = {col_s_voc, col_e_voc, col_ch2o};

        bool changed = false;
        for (int i = 0; i < 3; ++i)
          if (!std::isnan(vals[i]) && vals[i] != prev_voc[i]) changed = true;

        bool stale = (now - last_voc_update) > 45000UL;
        if (changed || stale) {
          draw_row(H_TEMP_HUM + 2*H_ROW, "VOC", "ppb",
                   names, vals, cols);
          for (int i = 0; i < 3; ++i) prev_voc[i] = vals[i];
          last_voc_update = now;
        }
      }

      // ---- SGP41 VOC / NOx indices ----------------------------------
      static float prev_aqi_voc = NAN;
      static float prev_aqi_nox = NAN;
      static uint32_t last_sgp41_update = 0;
      if (!std::isnan(aqi_voc) || !std::isnan(aqi_nox)) {
        bool changed = (aqi_voc != prev_aqi_voc) ||
                       (aqi_nox != prev_aqi_nox);
        bool stale   = (now - last_sgp41_update) > 45000UL;

        if (changed || stale) {
          // erase only the SGP41 lane
          it.filled_rectangle(0,
                               H_TEMP_HUM + 3*H_ROW,
                               w, H_SGP41_IDX,
                               Color::BLACK);

          const char *sgp = std::isnan(aqi_nox) ? "SGP40" : "SGP41";

          int y = H_TEMP_HUM + 3*H_ROW + 2;   // a little top margin

          if (!std::isnan(aqi_voc)) {
            it.printf(2, y, fl14, id(grey), TextAlign::CENTER_LEFT,
                      "%s VOC Index", sgp);
            it.printf(w-2, y, fl14, id(grey), TextAlign::CENTER_RIGHT,
                      "(1 … 500)");
            it.printf(w-2, y+12, fl14, id(white), TextAlign::CENTER_RIGHT,
                      "%.0f ", aqi_voc);
            y += 15;
          }
          if (!std::isnan(aqi_nox)) {
            it.printf(2, y, fl14, id(grey), TextAlign::CENTER_LEFT,
                      "%s NOx Index", sgp);
            it.printf(w-2, y, fl14, id(grey), TextAlign::CENTER_RIGHT,
                      "(1 … 500)");
            it.printf(w-2, y+12, fl14, id(white), TextAlign::CENTER_RIGHT,
                      "%.0f ", aqi_nox);
          }

          prev_aqi_voc = aqi_voc;
          prev_aqi_nox = aqi_nox;
          last_sgp41_update = now;
        }
      }

    dimensions:
      height: 320
      width: 240



uart:
  - tx_pin: GPIO10
    rx_pin: GPIO09
    baud_rate: 9600
    id: uart_ze08
    parity: none
    data_bits: 8
    stop_bits: 1
    debug: 
      direction: BOTH
      dummy_receiver: true
      after:
        # bytes: 9 
        timeout: 10ms
      sequence:
        - lambda: |-
            //UARTDebug::log_int(direction, bytes, ',');                 // Log the message as int. 
            //UARTDebug::log_hex(direction, bytes, ',');                 // Log the message in hex.
            ESP_LOGD("custom", "Bytes size: %d", bytes.size());
            if (direction == UART_DIRECTION_RX)                        
              {
                  if (bytes.size() == 9)                               
                    {
                        if ( bytes[0] == 0xFF &&                       // Check sensor identification
                            bytes[1] == 0x17
                            )       
                          {
                            float value = float((bytes[4] * 256) + bytes[5]);  // Decode message
                            id(ch2o_ze08).publish_state(value);     // Publish results to a sensor.
                          }
                    }
              }

  - tx_pin: GPIO08
    rx_pin: GPIO07
    baud_rate: 9600
    id: uart_pms

spi:
  clk_pin: GPIO01
  mosi_pin: GPIO02
  miso_pin: GPIO16

i2c:
  - sda: GPIO11
    scl: GPIO12
    scan: true
    id: i2c_main

  - sda: GPIO17
    scl: GPIO18
    scan: true
    id: i2c_2

sensor:
  - platform: template
    name: "ZE08 CH2O"
    unit_of_measurement: ppb
    state_class: measurement
    device_class: volatile_organic_compounds
    id: ch2o_ze08
    filters: 
      - filter_out: 2000.0
      - exponential_moving_average: 
          send_every: 1
          alpha: 0.5

  - platform: uptime
    name: "Uptime"
    id: uptime_sensor
    update_interval: 5s
    disabled_by_default: True

  - platform: debug
    free:
      name: "Heap Free"
      id: heap_free
      disabled_by_default: True
    loop_time:
      name: "Loop Time"
      id: loop_time
      disabled_by_default: True

  - platform: aht10
    #address: 0x38
    i2c_id: i2c_main
    variant: AHT20
    temperature:
      name: "AHT20 Temperature"
      id: temp_aht20
      filters:
        # Convert °C to °F
        - lambda: |-
            return x * 1.8 + 32;
    humidity:
      name: "AHT20 Humidity"
      id: hum_aht20
    update_interval: 10s

  - platform: bmp280_i2c
    address: 0x77
    i2c_id: i2c_main
    temperature:
      name: "BMP280 Temperature"
      id: temp_bmp280
      oversampling: 16x
    pressure:
      name: "BMP280 Pressure"
      id: pres_bmp280
    update_interval: 10s


  - platform: sht4x
    #addr 0x44
    i2c_id: i2c_main
    temperature:
      name: "SHT40 Temperature"
      id: temp_sht40
    humidity:
      name: "SHT40 Relative Humidity"
      id: hum_sht40
    update_interval: 10s

  - platform: scd4x
    #address: 0x62
    i2c_id: i2c_main
    co2:
      name: "SCD40 CO2"
      id: co2_scd40
    temperature:
      name: "SCD40 Temperature"
      id: temp_scd40
    humidity:
      name: "SCD40 Humidity"
      id: hum_scd40
    update_interval: 20s

  - platform: ens160_i2c
    address: 0x53
    i2c_id: i2c_2
    eco2:
      name: "ENS160 eCO2"
      id: eco2_ens160
    tvoc:
      name: "ENS160 TVOC"
      id: tvoc_ens160
      filters: 
        - exponential_moving_average: 
            send_every: 1
            alpha: 0.5
    aqi:
      name: "ENS160 Air Quality Index"
      id: aqi_ens160
    update_interval: 10s
    compensation:
      temperature: temp_aht20_ens
      humidity: hum_aht20_ens

  - platform: aht10
    #address: 0x38
    i2c_id: i2c_2
    variant: AHT20
    temperature:
      name: "AHT20/ENS160 Temperature"
      id: temp_aht20_ens
      disabled_by_default: True
    humidity:
      name: "AHT20/ENS160 Humidity"
      id: hum_aht20_ens
      disabled_by_default: True
    update_interval: 10s

  - platform: sgp30
    i2c_id: i2c_main
    address: 0x58
    eco2:
      name: "SGP30 eCO2"
      id: eco2_sgp30
      accuracy_decimals: 0
      filters: 
        - exponential_moving_average: 
            send_every: 1
            alpha: 0.2
    tvoc:
      name: "SGP30 TVOC"
      id: tvoc_sgp30
      accuracy_decimals: 1
      filters: 
        - exponential_moving_average: 
            send_every: 1
            alpha: 0.2
    store_baseline: yes
    update_interval: 5s
    compensation: 
      humidity_source: hum_aht20
      temperature_source: temp_aht20

  - platform: sgp4x
    i2c_id: i2c_main
    #address: 0x59
    voc:
      name: "SGP41 VOC Index"
      id: aqi_voc_sgp41
      icon: "mdi:air-filter"
      device_class: aqi
      state_class: measurement
      unit_of_measurement: "index points"
    nox:
      name: "SGP41 NOx Index"
      id: aqi_nox_sgp41
      icon: "mdi:air-filter"
      device_class: aqi
      state_class: measurement
      unit_of_measurement: "index points"
    compensation: 
      humidity_source: hum_aht20
      temperature_source: temp_aht20
    store_baseline: True
    update_interval: 10s

  - platform: pmsx003
    type: PMSX003 
    update_interval: 30s
    uart_id: uart_pms
    pm_1_0:
      name: "PMS Particulate Matter <1.0µm Concentration"
      id: pm1_pms
    pm_2_5:
      name: "PMS Particulate Matter <2.5µm Concentration"
      id: pm25_pms
    pm_10_0:
      name: "PMS Particulate Matter <10.0µm Concentration"
      id: pm10_pms
